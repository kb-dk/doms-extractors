package dk.statsbiblioteket.doms.radiotv.extractor.transcoder.extractor;

import dk.statsbiblioteket.doms.radiotv.extractor.transcoder.ProcessorChainElement;
import dk.statsbiblioteket.doms.radiotv.extractor.transcoder.ProcessorException;
import dk.statsbiblioteket.doms.radiotv.extractor.transcoder.ShardStructure;
import dk.statsbiblioteket.doms.radiotv.extractor.transcoder.TranscodeRequest;

import javax.servlet.ServletConfig;


/**
 * This processor uses the data generated by ShardAnalyserProcessor to fix shards
 * where possible or to abort transcoding where desirable.
 */
public class ShardFixerProcessor extends ProcessorChainElement {

    private static final int MAX_HOLE_SIZE = 120;

    @Override
    protected void processThis(TranscodeRequest request, ServletConfig config) throws ProcessorException {
        final ShardStructure structure = request.getStructure();
        if (structure.isNonTrivial()) {
            if (structure.getMissingEnd() != null) {
                  throw new ProcessorException("Could not transcode '" + request.getPid() + "': missing end");
            }
            if (structure.getMissingStart() != null) {
                throw new ProcessorException("Could not transcode '" + request.getPid() + "': missing start");
            }
            if (!(structure.getHoles() == null) && !structure.getHoles().isEmpty()) {
                for ( ShardStructure.Hole hole: structure.getHoles()) {
                    if (hole.getHoleLength() > MAX_HOLE_SIZE) {
                        throw new ProcessorException("Could not transcode '" + request.getPid() +
                                "': hole of length '" + hole.getHoleLength() + "' seconds is greater than maximum " +
                                "tolerated value '" + MAX_HOLE_SIZE + "'");
                    }
                }
            }
            if (!(structure.getOverlaps() == null) && !structure.getOverlaps().isEmpty()) {
                for (ShardStructure.Overlap overlap: structure.getOverlaps()) {
                   processOverlap(request, config, overlap);
                }
            }
        }
    }

    private void processOverlap(TranscodeRequest request, ServletConfig config, ShardStructure.Overlap overlap) {

    }

}
